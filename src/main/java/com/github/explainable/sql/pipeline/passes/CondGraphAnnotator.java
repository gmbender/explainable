package com.github.explainable.sql.pipeline.passes;

import com.github.explainable.sql.ast.AbstractVisitor;
import com.github.explainable.sql.ast.SqlNode;
import com.github.explainable.sql.ast.expression.SqlBinaryExpression;
import com.github.explainable.sql.ast.expression.SqlBinaryExpression.BinaryOperator;
import com.github.explainable.sql.ast.expression.SqlExpression;
import com.github.explainable.sql.ast.expression.SqlIn;
import com.github.explainable.sql.ast.select.SqlFrom;
import com.github.explainable.sql.ast.select.SqlHavingClause;
import com.github.explainable.sql.ast.select.SqlOnClause;
import com.github.explainable.sql.ast.select.SqlPlainSelect;
import com.github.explainable.sql.ast.select.SqlSelectStmt;
import com.github.explainable.sql.ast.select.SqlWhereClause;
import com.github.explainable.sql.constraint.BaseColumnArg;
import com.github.explainable.sql.constraint.EqualityArg;
import com.github.explainable.sql.constraint.EqualityConstraint;
import com.github.explainable.sql.pipeline.DependsOn;
import com.github.explainable.sql.pipeline.TransformationPass;
import com.github.explainable.sql.table.BaseTable;
import com.github.explainable.util.LDVertex;
import com.google.common.base.Preconditions;

import javax.annotation.Nullable;
import java.util.Set;

/**
 * Pass that annotates the condition graph generated by {@link CondGraphInitializer} with
 * information about equality constraints between different variables and between variables and
 * constants. This pass serves two purposes. First, we associate a list of equality constraints with
 * each {@link SqlPlainSelect} in the AST. And second, for queries such as
 *
 * <pre>{@code SELECT 1 FROM Sailors S LEFT JOIN Reserves R WHERE (S.sid = R.sid)}</pre>
 *
 * we add edges from the {@code SELECT} statement's vertex to the vertices associated with {@code R}
 * and {@code S}. This is a finicky operation, and should not be done for queries such as
 *
 * <pre>{@code SELECT 1 FROM Sailors S LEFT JOIN Reserves R ON (S.sid = R.sid)}</pre>
 */
@DependsOn({AggTypeChecker.class, ColumnResolver.class, CondGraphInitializer.class})
final class CondGraphAnnotator implements TransformationPass {
	@Override
	public void execute(SqlSelectStmt select) {
		select.accept(new DefaultAnnotator(null), null);
	}

	private static final class DefaultAnnotator extends AbstractVisitor {
		@Nullable
		private final SqlPlainSelect outerSelect;

		DefaultAnnotator(@Nullable SqlPlainSelect outerSelect) {
			this.outerSelect = outerSelect;
		}

		@Override
		public AbstractVisitor enter(SqlPlainSelect select, SqlNode parent) {
			return new DefaultAnnotator(select);
		}

		@Override
		public AbstractVisitor enter(SqlOnClause on, SqlNode parent) {
			if (outerSelect == null) {
				throw new IllegalStateException();
			}

			return new OnAnnotator(outerSelect, ((SqlFrom) parent).dependentTables());
		}

		@Override
		public AbstractVisitor enter(SqlWhereClause where, SqlNode parent) {
			if (outerSelect == null) {
				throw new IllegalStateException();
			}

			return new WhereHavingAnnotator(outerSelect);
		}

		@Override
		public AbstractVisitor enter(SqlHavingClause having, SqlNode parent) {
			if (outerSelect == null) {
				throw new IllegalStateException();
			}

			return new WhereHavingAnnotator(outerSelect);
		}
	}

	private static abstract class PredicateAnnotator extends AbstractVisitor {
		private final SqlPlainSelect outerSelect;

		PredicateAnnotator(
				SqlPlainSelect outerSelect) {
			this.outerSelect = Preconditions.checkNotNull(outerSelect);
		}

		@Override
		protected AbstractVisitor defaultEnter(SqlNode node, SqlNode parent) {
			return new DefaultAnnotator(outerSelect);
		}

		@Override
		public AbstractVisitor enter(SqlBinaryExpression expr, SqlNode parent) {
			if (expr.operator() == BinaryOperator.AND) {
				return this;
			} else {
				return new DefaultAnnotator(outerSelect);
			}
		}

		@Override
		public void leave(SqlBinaryExpression expr, SqlNode parent) {
			if (expr.operator() == BinaryOperator.EQUALS_TO) {
				annotateEquality(expr.left(), expr.right());
				addEdgesForEqualityConstraint(
						expr.left().equalityArg(),
						expr.right().equalityArg());
			}
		}

		@Override
		public void leave(SqlIn in, SqlNode parent) {
			annotateEquality(in.left(), in.right());
			if (!in.isNot()) {
				addEdgesForEqualityConstraint(
						in.left().equalityArg(),
						in.right().equalityArg());
			}
		}

		private void annotateEquality(
				SqlExpression left,
				SqlExpression right) {
			EqualityArg leftArg = left.equalityArg();
			EqualityArg rightArg = right.equalityArg();

			if (leftArg != null && rightArg != null) {
				LDVertex<Object, EqualityConstraint> vertex = outerSelect.getConditionVertex();
				vertex.annotate(EqualityConstraint.create(leftArg, rightArg));
			}
		}

		SqlPlainSelect outerSelect() {
			return outerSelect;
		}

		abstract void addEdgesForEqualityConstraint(EqualityArg leftArg, EqualityArg rightArg);
	}

	private static final class WhereHavingAnnotator extends PredicateAnnotator {
		WhereHavingAnnotator(SqlPlainSelect outerSelect) {
			super(outerSelect);
		}

		@Override
		void addEdgesForEqualityConstraint(EqualityArg leftArg, EqualityArg rightArg) {
			if (leftArg instanceof BaseColumnArg) {
				LDVertex<Object, EqualityConstraint> leftVertex
						= ((BaseColumnArg) leftArg).column().parent().getConditionVertex();

				outerSelect().getConditionVertex().addEdge(leftVertex);
			}

			if (rightArg instanceof BaseColumnArg) {
				LDVertex<Object, EqualityConstraint> rightVertex
						= ((BaseColumnArg) rightArg).column().parent().getConditionVertex();

				outerSelect().getConditionVertex().addEdge(rightVertex);
			}
		}
	}

	private static final class OnAnnotator extends PredicateAnnotator {
		private final Set<BaseTable> dependentTables;

		OnAnnotator(SqlPlainSelect outerSelect, Set<BaseTable> dependentTables) {
			super(outerSelect);

			this.dependentTables = Preconditions.checkNotNull(dependentTables);
		}

		@Override
		void addEdgesForEqualityConstraint(EqualityArg leftArg, EqualityArg rightArg) {
			if (leftArg instanceof BaseColumnArg) {
				LDVertex<Object, EqualityConstraint> leftVertex
						= ((BaseColumnArg) leftArg).column().parent().getConditionVertex();

				for (BaseTable table : dependentTables) {
					table.getConditionVertex().addEdge(leftVertex);
				}
			}

			if (rightArg instanceof BaseColumnArg) {
				LDVertex<Object, EqualityConstraint> rightVertex
						= ((BaseColumnArg) rightArg).column().parent().getConditionVertex();

				for (BaseTable table : dependentTables) {
					table.getConditionVertex().addEdge(rightVertex);
				}
			}
		}
	}
}